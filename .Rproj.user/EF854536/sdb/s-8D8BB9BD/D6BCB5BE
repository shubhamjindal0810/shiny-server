{
    "contents" : "#!/usr/bin/env python\n# Copyright (c) 2010 Erik Karulf (erik@karulf.com)\n# \n# Permission to use, copy, modify, and/or distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE\n\nimport Image\nimport ImageDraw\n\n# Copied from http://en.wikipedia.org/wiki/Code_128\n# Value Weights 128A    128B    128C\nCODE128_CHART = \"\"\"\n0       212222  space   space   00\n1       222122  !       !       01\n2       222221  \"       \"       02\n3       121223  #       #       03\n4       121322  $       $       04\n5       131222  %       %       05\n6       122213  &       &       06\n7       122312  '       '       07\n8       132212  (       (       08\n9       221213  )       )       09\n10      221312  *       *       10\n11      231212  +       +       11\n12      112232  ,       ,       12\n13      122132  -       -       13\n14      122231  .       .       14\n15      113222  /       /       15\n16      123122  0       0       16\n17      123221  1       1       17\n18      223211  2       2       18\n19      221132  3       3       19\n20      221231  4       4       20\n21      213212  5       5       21\n22      223112  6       6       22\n23      312131  7       7       23\n24      311222  8       8       24\n25      321122  9       9       25\n26      321221  :       :       26\n27      312212  ;       ;       27\n28      322112  <       <       28\n29      322211  =       =       29\n30      212123  >       >       30\n31      212321  ?       ?       31\n32      232121  @       @       32\n33      111323  A       A       33\n34      131123  B       B       34\n35      131321  C       C       35\n36      112313  D       D       36\n37      132113  E       E       37\n38      132311  F       F       38\n39      211313  G       G       39\n40      231113  H       H       40\n41      231311  I       I       41\n42      112133  J       J       42\n43      112331  K       K       43\n44      132131  L       L       44\n45      113123  M       M       45\n46      113321  N       N       46\n47      133121  O       O       47\n48      313121  P       P       48\n49      211331  Q       Q       49\n50      231131  R       R       50\n51      213113  S       S       51\n52      213311  T       T       52\n53      213131  U       U       53\n54      311123  V       V       54\n55      311321  W       W       55\n56      331121  X       X       56\n57      312113  Y       Y       57\n58      312311  Z       Z       58\n59      332111  [       [       59\n60      314111  \\       \\       60\n61      221411  ]       ]       61\n62      431111  ^       ^       62\n63      111224  _       _       63\n64      111422  NUL     `       64\n65      121124  SOH     a       65\n66      121421  STX     b       66\n67      141122  ETX     c       67\n68      141221  EOT     d       68\n69      112214  ENQ     e       69\n70      112412  ACK     f       70\n71      122114  BEL     g       71\n72      122411  BS      h       72\n73      142112  HT      i       73\n74      142211  LF      j       74\n75      241211  VT      k       75\n76      221114  FF      l       76\n77      413111  CR      m       77\n78      241112  SO      n       78\n79      134111  SI      o       79\n80      111242  DLE     p       80\n81      121142  DC1     q       81\n82      121241  DC2     r       82\n83      114212  DC3     s       83\n84      124112  DC4     t       84\n85      124211  NAK     u       85\n86      411212  SYN     v       86\n87      421112  ETB     w       87\n88      421211  CAN     x       88\n89      212141  EM      y       89\n90      214121  SUB     z       90\n91      412121  ESC     {       91\n92      111143  FS      |       92\n93      111341  GS      }       93\n94      131141  RS      ~       94\n95      114113  US      DEL     95\n96      114311  FNC3    FNC3    96\n97      411113  FNC2    FNC2    97\n98      411311  ShiftB  ShiftA  98\n99      113141  CodeC   CodeC   99\n100     114131  CodeB   FNC4    CodeB\n101     311141  FNC4    CodeA   CodeA\n102     411131  FNC1    FNC1    FNC1\n103     211412  StartA  StartA  StartA\n104     211214  StartB  StartB  StartB\n105     211232  StartC  StartC  StartC\n106     2331112 Stop    Stop    Stop\n\"\"\".split()\n\nVALUES   = [int(value) for value in CODE128_CHART[0::5]]\nWEIGHTS  = dict(zip(VALUES, CODE128_CHART[1::5]))\nCODE128A = dict(zip(CODE128_CHART[2::5], VALUES))\nCODE128B = dict(zip(CODE128_CHART[3::5], VALUES))\nCODE128C = dict(zip(CODE128_CHART[4::5], VALUES))\n\nfor charset in (CODE128A, CODE128B):\n    charset[' '] = charset.pop('space')\n\ndef code128_format(data):\n    \"\"\"\n    Generate an optimal barcode from ASCII text\n    \"\"\"\n    text     = str(data)\n    pos      = 0\n    length   = len(text)\n    \n    # Start Code\n    if text[:2].isdigit() and length > 1:\n        charset = CODE128C\n        codes   = [charset['StartC']]\n    else:\n        charset = CODE128B\n        codes   = [charset['StartB']]\n    \n    # Data\n    while pos < length:\n        if charset is CODE128C:\n            if text[pos:pos+2].isdigit() and length - pos > 1:\n                # Encode Code C two characters at a time\n                codes.append(int(text[pos:pos+2]))\n                pos += 2\n            else:\n                # Switch to Code B\n                codes.append(charset['CodeB'])\n                charset = CODE128B\n        elif text[pos:pos+4].isdigit() and length - pos >= 4:\n            # Switch to Code C\n            codes.append(charset['CodeC'])\n            charset = CODE128C\n        else:\n            # Encode Code B one character at a time\n            codes.append(charset[text[pos]])\n            pos += 1\n    \n    # Checksum\n    checksum = 0\n    for weight, code in enumerate(codes):\n        checksum += max(weight, 1) * code\n    codes.append(checksum % 103)\n    \n    # Stop Code\n    codes.append(charset['Stop'])\n    return codes\n\ndef code128_image(data, height=100, thickness=3, quiet_zone=True):\n    if not data[-1] == CODE128B['Stop']:\n        data = code128_format(data)\n    \n    barcode_widths = []\n    for code in data:\n        for weight in WEIGHTS[code]:\n            barcode_widths.append(int(weight) * thickness)\n    width = sum(barcode_widths)\n    x = 0\n\n    if quiet_zone:\n        width += 20 * thickness\n        x = 10 * thickness\n\n    # Monochrome Image\n    img  = Image.new('1', (width, height), 1)\n    draw = ImageDraw.Draw(img)\n    draw_bar = True\n    for width in barcode_widths:\n        if draw_bar:\n            draw.rectangle(((x, 0), (x + width - 1, height)), fill=0)\n        draw_bar = not draw_bar\n        x += width\n\n    return img\n",
    "created" : 1442770256613.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3533353106",
    "id" : "D6BCB5BE",
    "lastKnownWriteTime" : 1442770289,
    "path" : "~/shiny-server/code128.py",
    "project_path" : "code128.py",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "python"
}